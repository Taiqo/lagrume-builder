import { select, getNumber } from './utilities';

/**
 * Slider class
 */
export default class Slider {
  /**
   * class constructor
   * @param {HTMLElement}   element
   * @param {Boolean|Array} gradient
   * @param {Number}        min
   * @param {Number}        max
   * @param {Number}        step
   * @param {Number}        value
   */
  constructor(selector, {
    gradient = null,
    colorCode = false,
    min = 0,
    max = 10,
    step = 1,
    value = 0
  } = {}) {
    this.el = select(selector);
    this.settings = {
      gradient,
      colorCode,
      min,
      max,
      step,
      value
    };
    this.init();
  }

  /**
   * create new rang slider element
   * @param {HTMLElement} element
   * @param {Object}      settings
   */
  static create(selector, settings) {
    new Slider(selector, settings);
  }

  init() {
    this.initHTML();
    this.input = this.el.querySelector('input');
    this.track = this.el.querySelector('.slider-body');
    this.handle = this.el.querySelector('.slider-handle');
    this.fill = this.el.querySelector('.slider-fill');
    this.label = this.el.querySelector('.slider-label');
    this.input = this.el.querySelector('input');
    this.min = getNumber(this.input.min, this.settings.min);
    this.max = getNumber(this.input.max, this.settings.max);
    this.step = getNumber(this.input.step, this.settings.step);
    this.value = getNumber(this.input.value, this.settings.value);
    this.currentValue = '';
    this.showColor = false;
    this.callbacks = {};

    if (this.settings.gradient) this.initGradient();

    this.updateWidth();
    this.update(this.value);
    this.initEvents();
    this.input.addEventListener('input', () => {
      this.update(this.input.value);
    }, false);
  }

  initHTML() {
    this.sliderHTML = `<div class="slider-body">
                        <div class="slider-fill"></div>
                        <div class="slider-handle">
                          <span class="slider-label">0</span>
                        </div>
                      </div>`;
    this.el.insertAdjacentHTML('afterbegin', this.sliderHTML);
  }

  initGradient() {
    if (this.settings.gradient.length > 1) {
      this.track.style.backgroundImage = `linear-gradient(90deg, ${this.settings.gradient})`;
      this.gradient = this.settings.gradient;
      this.colorCode = this.settings.colorCode;
      return;
    }
    this.track.style.backgroundColor = this.settings.gradient[0];
    this.handle.style.backgroundColor = this.settings.gradient[0];
    this.gradient = null;
    this.showColor = false;
  }

  initEvents() {
    this.track.addEventListener('mousedown', this.select.bind(this), false);
    this.track.addEventListener('touchstart', this.select.bind(this), false);
  }

  /**
   * fire select events
   * @param {Object} slider
   */
  select(event) {
    this.updateWidth();
    this.click(event);
    // this.click();
    this.callbacks.tempDrag = this.dragging.bind(this);
    this.callbacks.tempRelease = this.release.bind(this);
    document.addEventListener('mousemove', this.callbacks.tempDrag, false);
    document.addEventListener('touchmove', this.callbacks.tempDrag, false);
    document.addEventListener('touchend', this.callbacks.tempRelease, false);
    document.addEventListener('mouseup', this.callbacks.tempRelease, false);
  }

  /**
   * dragging motion
   * @param {Object} slider
   */
  dragging(event) {
    event.preventDefault();
    // get drag change value
    const eventX = event.type === 'mousemove' ? event.clientX : event.touches[0].clientX;
    const mouseValue = (eventX - this.currentX);

    // check if  left mouse is clicked
    if (event.buttons !== 1 && event.type === 'mousemove') return;
    this.track.classList.add('is-dragging');
    const stepCount = parseInt((mouseValue / this.stepWidth) + 0.5, 10);
    const stepValue = parseInt((stepCount + this.min) / this.step, 10) * this.step;
    if (stepValue !== this.currentValue) {
      this.update(stepValue);
    }
  }

  /**
   * release handler
   * @param {Object} slider
   */
  release() {
    this.track.classList.remove('is-dragging');
    document.removeEventListener('mousemove', this.callbacks.tempDrag);
    document.removeEventListener('touchmove', this.callbacks.tempDrag);
    document.removeEventListener('mouseup', this.callbacks.tempRelease);
    document.removeEventListener('touchend', this.callbacks.tempRelease);
  }

  click(event) {
    const eventX = event.type === 'mousedown' ? event.clientX : event.touches[0].clientX;
    const mouseValue = (eventX - this.currentX);

    // check if  left mouse is clicked
    if (event.buttons !== 1 && event.type === 'mousemove') return;
    const stepCount = parseInt((mouseValue / this.stepWidth) + 0.5, 10);
    const stepValue = parseInt((stepCount + this.min) / this.step, 10) * this.step;
    if (stepValue !== this.currentValue) {
      this.update(stepValue);
    }
  }

  updateWidth() {
    this.currentX = this.track.getBoundingClientRect().left;
    this.width = this.track.clientWidth;
    this.stepWidth = (this.width / (this.max - this.min));
  }

  /**
   * get the filled area percentage
   * @param  {Object} slider
   * @param  {Number} value
   * @return {Number}
   */
  getFillPercentage(value) {
    if (value <= this.max && value >= this.min) {
      return (value - this.min) / (this.max - this.min);
    }
    if (value >= this.max) {
      return 1;
    }
    if (value <= this.min) {
      return 0;
    }
    return 0;
  }

  /**
   * get the handle color
   * @param  {Object} slider
   * @param  {Number} fillPercentage
   * @return {Number}                handle hex color code
   */
  getHandleColor(fillPercentage) {
    const colorCount = this.gradient.length - 1;
    for (let i = 1; i <= colorCount; i++) {
      // check the current zone
      if (fillPercentage >= ((i - 1) / colorCount) && fillPercentage <= (i / colorCount)) {
        // get the active color percentage
        const colorPercentage = (fillPercentage - ((i - 1) / colorCount)) / (1 / colorCount);
        // return the mixed color based on the zone boundary colors
        return Slider.mixColors(this.gradient[i - 1],
          this.gradient[i], colorPercentage);
      }
    }
    return '#000000';
  }

  /**
   * update the slider fill, value and color
   * @param {Object} slider
   * @param {Number} value
   */
  update(value) {
    const fillPercentage = this.getFillPercentage(value);

    this.handle.style.left = `${fillPercentage * 100}%`;
    this.fill.style.left = `${fillPercentage * 100}%`;

    if (fillPercentage === 1) {
      this.value = this.max;
    } else if (fillPercentage === 0) {
      this.value = this.min;
    } else {
      this.value = value;
    }

    this.currentValue = this.value;
    this.label.innerHTML = this.value;
    this.input.value = this.value;

    if (this.gradient) {
      const color = this.getHandleColor(fillPercentage);
      this.handle.style.backgroundColor = color;
      if (this.colorCode) this.input.value = color;
    }
    this.input.dispatchEvent(new Event('change'));
  }

  /**
   * private functions
   */
  static hexAverage(color1, color2, ratio = 0.5) {
    const average = (parseInt(color1, 16) * (1 - ratio)) + (parseInt(color2, 16) * ratio);
    return (`00${Math.floor(average + 0.5).toString(16)}`).slice(-2);
  }

  static mixColors(color1, color2, ratio) {
    color1 = color1.replace('#', '');
    color2 = color2.replace('#', '');
    const red = Slider.hexAverage(color1.slice(0, -4), color2.slice(0, -4), ratio);
    const green = Slider.hexAverage(color1.slice(2, -2), color2.slice(2, -2), ratio);
    const blue = Slider.hexAverage(color1.slice(-2), color2.slice(-2), ratio);
    return `#${(red + green + blue).toUpperCase()}`;
  }
}
